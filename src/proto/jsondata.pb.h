// This file is AUTOGENERATED, do not edit.
#pragma once
#include "utils/protomessage.h"
namespace pblczero {
  class WDL : public lczero::ProtoMessage {
   public:

    bool has_w() const { return has_w_; }
    float w() const { return w_; }
    void set_w(float val) {
      has_w_ = true;
      w_ = val;
    }

    bool has_d() const { return has_d_; }
    float d() const { return d_; }
    void set_d(float val) {
      has_d_ = true;
      d_ = val;
    }

    bool has_l() const { return has_l_; }
    float l() const { return l_; }
    void set_l(float val) {
      has_l_ = true;
      l_ = val;
    }

    std::string OutputAsString() const override {
      std::string out;
      if (has_w_) AppendInt32(1, bit_cast<std::uint32_t>(w_), &out);
      if (has_d_) AppendInt32(2, bit_cast<std::uint32_t>(d_), &out);
      if (has_l_) AppendInt32(3, bit_cast<std::uint32_t>(l_), &out);
      return out;
    }

    std::string OutputAsJson() const override {
      bool first = true;
      std::string out = "{";
      if (has_w_) AppendJsonField("w", w_, &first, &out);
      if (has_d_) AppendJsonField("d", d_, &first, &out);
      if (has_l_) AppendJsonField("l", l_, &first, &out);
      out += "}";
      return out;
    }

    void Clear() override {
      has_w_ = false;
      w_ = {};
      has_d_ = false;
      d_ = {};
      has_l_ = false;
      l_ = {};
    }

   private:
    void SetInt32(int field_id, std::uint32_t val) override {
      switch (field_id) {
        case 1: set_w(bit_cast<float>(val)); break;
        case 2: set_d(bit_cast<float>(val)); break;
        case 3: set_l(bit_cast<float>(val)); break;
      }
    }

    bool has_w_{};
    float w_{};
    bool has_d_{};
    float d_{};
    bool has_l_{};
    float l_{};
  };
  class Evaluation : public lczero::ProtoMessage {
   public:

    bool has_cp() const { return has_cp_; }
    std::uint32_t cp() const { return cp_; }
    void set_cp(std::uint32_t val) {
      has_cp_ = true;
      cp_ = val;
    }

    bool has_winprob() const { return has_winprob_; }
    float winprob() const { return winprob_; }
    void set_winprob(float val) {
      has_winprob_ = true;
      winprob_ = val;
    }

    bool has_wdl() const { return has_wdl_; }
    const WDL& wdl() const { return wdl_; }
    WDL* mutable_wdl() {
      has_wdl_ = true;
      return &wdl_;
    }

    bool has_mate() const { return has_mate_; }
    std::uint32_t mate() const { return mate_; }
    void set_mate(std::uint32_t val) {
      has_mate_ = true;
      mate_ = val;
    }

    std::string OutputAsString() const override {
      std::string out;
      if (has_cp_) AppendVarInt(1, cp_, &out);
      if (has_winprob_) AppendInt32(2, bit_cast<std::uint32_t>(winprob_), &out);
      if (has_wdl_) AppendString(3, wdl_.OutputAsString(), &out);
      if (has_mate_) AppendVarInt(4, mate_, &out);
      return out;
    }

    std::string OutputAsJson() const override {
      bool first = true;
      std::string out = "{";
      if (has_cp_) AppendJsonField("cp", cp_, &first, &out);
      if (has_winprob_) AppendJsonField("winprob", winprob_, &first, &out);
      if (has_wdl_) AppendJsonField("wdl", wdl_, &first, &out);
      if (has_mate_) AppendJsonField("mate", mate_, &first, &out);
      out += "}";
      return out;
    }

    void Clear() override {
      has_cp_ = false;
      cp_ = {};
      has_winprob_ = false;
      winprob_ = {};
      has_wdl_ = false;
      wdl_ = {};
      has_mate_ = false;
      mate_ = {};
    }

   private:
    void SetVarInt(int field_id, std::uint64_t val) override {
      switch (field_id) {
        case 1: set_cp(static_cast<std::uint32_t>(UnZigZag(val))); break;
        case 4: set_mate(static_cast<std::uint32_t>(UnZigZag(val))); break;
      }
    }
    void SetInt32(int field_id, std::uint32_t val) override {
      switch (field_id) {
        case 2: set_winprob(bit_cast<float>(val)); break;
      }
    }
    void SetString(int field_id, std::string_view val) override {
      switch (field_id) {
        case 3: mutable_wdl()->MergeFromString(val); break;
      }
    }

    bool has_cp_{};
    std::uint32_t cp_{};
    bool has_winprob_{};
    float winprob_{};
    bool has_wdl_{};
    WDL wdl_{};
    bool has_mate_{};
    std::uint32_t mate_{};
  };
  class Lc0MoveInfo : public lczero::ProtoMessage {
   public:

    bool has_n() const { return has_n_; }
    std::uint64_t n() const { return n_; }
    void set_n(std::uint64_t val) {
      has_n_ = true;
      n_ = val;
    }

    bool has_n_in_flight() const { return has_n_in_flight_; }
    std::uint32_t n_in_flight() const { return n_in_flight_; }
    void set_n_in_flight(std::uint32_t val) {
      has_n_in_flight_ = true;
      n_in_flight_ = val;
    }

    bool has_p() const { return has_p_; }
    float p() const { return p_; }
    void set_p(float val) {
      has_p_ = true;
      p_ = val;
    }

    bool has_wl() const { return has_wl_; }
    float wl() const { return wl_; }
    void set_wl(float val) {
      has_wl_ = true;
      wl_ = val;
    }

    bool has_d() const { return has_d_; }
    float d() const { return d_; }
    void set_d(float val) {
      has_d_ = true;
      d_ = val;
    }

    bool has_ml() const { return has_ml_; }
    float ml() const { return ml_; }
    void set_ml(float val) {
      has_ml_ = true;
      ml_ = val;
    }

    bool has_q() const { return has_q_; }
    float q() const { return q_; }
    void set_q(float val) {
      has_q_ = true;
      q_ = val;
    }

    bool has_v() const { return has_v_; }
    float v() const { return v_; }
    void set_v(float val) {
      has_v_ = true;
      v_ = val;
    }

    bool has_u() const { return has_u_; }
    float u() const { return u_; }
    void set_u(float val) {
      has_u_ = true;
      u_ = val;
    }

    bool has_s() const { return has_s_; }
    float s() const { return s_; }
    void set_s(float val) {
      has_s_ = true;
      s_ = val;
    }

    bool has_visited_policy() const { return has_visited_policy_; }
    float visited_policy() const { return visited_policy_; }
    void set_visited_policy(float val) {
      has_visited_policy_ = true;
      visited_policy_ = val;
    }

    std::string OutputAsString() const override {
      std::string out;
      if (has_n_) AppendVarInt(1, n_, &out);
      if (has_n_in_flight_) AppendVarInt(2, n_in_flight_, &out);
      if (has_p_) AppendInt32(3, bit_cast<std::uint32_t>(p_), &out);
      if (has_wl_) AppendInt32(4, bit_cast<std::uint32_t>(wl_), &out);
      if (has_d_) AppendInt32(5, bit_cast<std::uint32_t>(d_), &out);
      if (has_ml_) AppendInt32(6, bit_cast<std::uint32_t>(ml_), &out);
      if (has_q_) AppendInt32(7, bit_cast<std::uint32_t>(q_), &out);
      if (has_v_) AppendInt32(8, bit_cast<std::uint32_t>(v_), &out);
      if (has_u_) AppendInt32(9, bit_cast<std::uint32_t>(u_), &out);
      if (has_s_) AppendInt32(10, bit_cast<std::uint32_t>(s_), &out);
      if (has_visited_policy_) AppendInt32(11, bit_cast<std::uint32_t>(visited_policy_), &out);
      return out;
    }

    std::string OutputAsJson() const override {
      bool first = true;
      std::string out = "{";
      if (has_n_) AppendJsonField("n", n_, &first, &out);
      if (has_n_in_flight_) AppendJsonField("n_in_flight", n_in_flight_, &first, &out);
      if (has_p_) AppendJsonField("p", p_, &first, &out);
      if (has_wl_) AppendJsonField("wl", wl_, &first, &out);
      if (has_d_) AppendJsonField("d", d_, &first, &out);
      if (has_ml_) AppendJsonField("ml", ml_, &first, &out);
      if (has_q_) AppendJsonField("q", q_, &first, &out);
      if (has_v_) AppendJsonField("v", v_, &first, &out);
      if (has_u_) AppendJsonField("u", u_, &first, &out);
      if (has_s_) AppendJsonField("s", s_, &first, &out);
      if (has_visited_policy_) AppendJsonField("visited_policy", visited_policy_, &first, &out);
      out += "}";
      return out;
    }

    void Clear() override {
      has_n_ = false;
      n_ = {};
      has_n_in_flight_ = false;
      n_in_flight_ = {};
      has_p_ = false;
      p_ = {};
      has_wl_ = false;
      wl_ = {};
      has_d_ = false;
      d_ = {};
      has_ml_ = false;
      ml_ = {};
      has_q_ = false;
      q_ = {};
      has_v_ = false;
      v_ = {};
      has_u_ = false;
      u_ = {};
      has_s_ = false;
      s_ = {};
      has_visited_policy_ = false;
      visited_policy_ = {};
    }

   private:
    void SetVarInt(int field_id, std::uint64_t val) override {
      switch (field_id) {
        case 1: set_n(static_cast<std::uint64_t>(val)); break;
        case 2: set_n_in_flight(static_cast<std::uint32_t>(val)); break;
      }
    }
    void SetInt32(int field_id, std::uint32_t val) override {
      switch (field_id) {
        case 3: set_p(bit_cast<float>(val)); break;
        case 4: set_wl(bit_cast<float>(val)); break;
        case 5: set_d(bit_cast<float>(val)); break;
        case 6: set_ml(bit_cast<float>(val)); break;
        case 7: set_q(bit_cast<float>(val)); break;
        case 8: set_v(bit_cast<float>(val)); break;
        case 9: set_u(bit_cast<float>(val)); break;
        case 10: set_s(bit_cast<float>(val)); break;
        case 11: set_visited_policy(bit_cast<float>(val)); break;
      }
    }

    bool has_n_{};
    std::uint64_t n_{};
    bool has_n_in_flight_{};
    std::uint32_t n_in_flight_{};
    bool has_p_{};
    float p_{};
    bool has_wl_{};
    float wl_{};
    bool has_d_{};
    float d_{};
    bool has_ml_{};
    float ml_{};
    bool has_q_{};
    float q_{};
    bool has_v_{};
    float v_{};
    bool has_u_{};
    float u_{};
    bool has_s_{};
    float s_{};
    bool has_visited_policy_{};
    float visited_policy_{};
  };
  class NodeInfo : public lczero::ProtoMessage {
   public:

    bool has_eval() const { return has_eval_; }
    const Evaluation& eval() const { return eval_; }
    Evaluation* mutable_eval() {
      has_eval_ = true;
      return &eval_;
    }

    bool has_depth() const { return has_depth_; }
    std::uint32_t depth() const { return depth_; }
    void set_depth(std::uint32_t val) {
      has_depth_ = true;
      depth_ = val;
    }

    bool has_seldepth() const { return has_seldepth_; }
    std::uint32_t seldepth() const { return seldepth_; }
    void set_seldepth(std::uint32_t val) {
      has_seldepth_ = true;
      seldepth_ = val;
    }

    bool has_nodes() const { return has_nodes_; }
    std::uint64_t nodes() const { return nodes_; }
    void set_nodes(std::uint64_t val) {
      has_nodes_ = true;
      nodes_ = val;
    }

    bool has_nps() const { return has_nps_; }
    std::uint32_t nps() const { return nps_; }
    void set_nps(std::uint32_t val) {
      has_nps_ = true;
      nps_ = val;
    }

    void add_pv(std::string_view val) { pv_.emplace_back(val); }
    const std::vector<std::string>& pv() const { return pv_; }
    std::string_view pv(size_t idx) const { return pv_[idx]; }
    size_t pv_size() const { return pv_.size(); }

    bool has_tbhits() const { return has_tbhits_; }
    std::uint64_t tbhits() const { return tbhits_; }
    void set_tbhits(std::uint64_t val) {
      has_tbhits_ = true;
      tbhits_ = val;
    }

    bool has_comment() const { return has_comment_; }
    std::string_view comment() const { return comment_; }
    void set_comment(std::string_view val) {
      has_comment_ = true;
      comment_ = val;
    }

    bool has_lc0_info() const { return has_lc0_info_; }
    const Lc0MoveInfo& lc0_info() const { return lc0_info_; }
    Lc0MoveInfo* mutable_lc0_info() {
      has_lc0_info_ = true;
      return &lc0_info_;
    }

    std::string OutputAsString() const override {
      std::string out;
      if (has_eval_) AppendString(1, eval_.OutputAsString(), &out);
      if (has_depth_) AppendVarInt(2, depth_, &out);
      if (has_seldepth_) AppendVarInt(3, seldepth_, &out);
      if (has_nodes_) AppendVarInt(4, nodes_, &out);
      if (has_nps_) AppendVarInt(5, nps_, &out);
      for (const auto& x : pv_) AppendString(6, x, &out);
      if (has_tbhits_) AppendVarInt(7, tbhits_, &out);
      if (has_comment_) AppendString(8, comment_, &out);
      if (has_lc0_info_) AppendString(9, lc0_info_.OutputAsString(), &out);
      return out;
    }

    std::string OutputAsJson() const override {
      bool first = true;
      std::string out = "{";
      if (has_eval_) AppendJsonField("eval", eval_, &first, &out);
      if (has_depth_) AppendJsonField("depth", depth_, &first, &out);
      if (has_seldepth_) AppendJsonField("seldepth", seldepth_, &first, &out);
      if (has_nodes_) AppendJsonField("nodes", nodes_, &first, &out);
      if (has_nps_) AppendJsonField("nps", nps_, &first, &out);
      if (!pv_.empty()) AppendJsonRepeatedField("pv", pv_, &first, &out);
      if (has_tbhits_) AppendJsonField("tbhits", tbhits_, &first, &out);
      if (has_comment_) AppendJsonField("comment", comment_, &first, &out);
      if (has_lc0_info_) AppendJsonField("lc0_info", lc0_info_, &first, &out);
      out += "}";
      return out;
    }

    void Clear() override {
      has_eval_ = false;
      eval_ = {};
      has_depth_ = false;
      depth_ = {};
      has_seldepth_ = false;
      seldepth_ = {};
      has_nodes_ = false;
      nodes_ = {};
      has_nps_ = false;
      nps_ = {};
      pv_.clear();
      has_tbhits_ = false;
      tbhits_ = {};
      has_comment_ = false;
      comment_ = {};
      has_lc0_info_ = false;
      lc0_info_ = {};
    }

   private:
    void SetString(int field_id, std::string_view val) override {
      switch (field_id) {
        case 1: mutable_eval()->MergeFromString(val); break;
        case 6: pv_.emplace_back(val); break;
        case 8: set_comment(val); break;
        case 9: mutable_lc0_info()->MergeFromString(val); break;
      }
    }
    void SetVarInt(int field_id, std::uint64_t val) override {
      switch (field_id) {
        case 2: set_depth(static_cast<std::uint32_t>(val)); break;
        case 3: set_seldepth(static_cast<std::uint32_t>(val)); break;
        case 4: set_nodes(static_cast<std::uint64_t>(val)); break;
        case 5: set_nps(static_cast<std::uint32_t>(val)); break;
        case 7: set_tbhits(static_cast<std::uint64_t>(val)); break;
      }
    }

    bool has_eval_{};
    Evaluation eval_{};
    bool has_depth_{};
    std::uint32_t depth_{};
    bool has_seldepth_{};
    std::uint32_t seldepth_{};
    bool has_nodes_{};
    std::uint64_t nodes_{};
    bool has_nps_{};
    std::uint32_t nps_{};
    std::vector<std::string> pv_;
    bool has_tbhits_{};
    std::uint64_t tbhits_{};
    bool has_comment_{};
    std::string comment_{};
    bool has_lc0_info_{};
    Lc0MoveInfo lc0_info_{};
  };
  class AlternativePosition : public lczero::ProtoMessage {
   public:

    void add_position(std::string_view val) { position_.emplace_back(val); }
    const std::vector<std::string>& position() const { return position_; }
    std::string_view position(size_t idx) const { return position_[idx]; }
    size_t position_size() const { return position_.size(); }

    bool has_info() const { return has_info_; }
    const NodeInfo& info() const { return info_; }
    NodeInfo* mutable_info() {
      has_info_ = true;
      return &info_;
    }

    std::string OutputAsString() const override {
      std::string out;
      for (const auto& x : position_) AppendString(1, x, &out);
      if (has_info_) AppendString(2, info_.OutputAsString(), &out);
      return out;
    }

    std::string OutputAsJson() const override {
      bool first = true;
      std::string out = "{";
      if (!position_.empty()) AppendJsonRepeatedField("position", position_, &first, &out);
      if (has_info_) AppendJsonField("info", info_, &first, &out);
      out += "}";
      return out;
    }

    void Clear() override {
      position_.clear();
      has_info_ = false;
      info_ = {};
    }

   private:
    void SetString(int field_id, std::string_view val) override {
      switch (field_id) {
        case 1: position_.emplace_back(val); break;
        case 2: mutable_info()->MergeFromString(val); break;
      }
    }

    std::vector<std::string> position_;
    bool has_info_{};
    NodeInfo info_{};
  };
  class JsonInfo : public lczero::ProtoMessage {
   public:

    bool has_posinfo() const { return has_posinfo_; }
    const NodeInfo& posinfo() const { return posinfo_; }
    NodeInfo* mutable_posinfo() {
      has_posinfo_ = true;
      return &posinfo_;
    }

    AlternativePosition* add_moves() { return &moves_.emplace_back(); }
    const std::vector<AlternativePosition>& moves() const { return moves_; }
    const AlternativePosition& moves(size_t idx) const { return moves_[idx]; }
    size_t moves_size() const { return moves_.size(); }

    std::string OutputAsString() const override {
      std::string out;
      if (has_posinfo_) AppendString(1, posinfo_.OutputAsString(), &out);
      for (const auto& x : moves_) AppendString(2, x.OutputAsString(), &out);
      return out;
    }

    std::string OutputAsJson() const override {
      bool first = true;
      std::string out = "{";
      if (has_posinfo_) AppendJsonField("posinfo", posinfo_, &first, &out);
      if (!moves_.empty()) AppendJsonRepeatedField("moves", moves_, &first, &out);
      out += "}";
      return out;
    }

    void Clear() override {
      has_posinfo_ = false;
      posinfo_ = {};
      moves_.clear();
    }

   private:
    void SetString(int field_id, std::string_view val) override {
      switch (field_id) {
        case 1: mutable_posinfo()->MergeFromString(val); break;
        case 2: add_moves()->MergeFromString(val); break;
      }
    }

    bool has_posinfo_{};
    NodeInfo posinfo_{};
    std::vector<AlternativePosition> moves_;
  };
}  // namespace pblczero
